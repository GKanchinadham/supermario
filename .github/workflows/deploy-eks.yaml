name: Deploy Luigi App to EKS

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      tenant_name:
        description: 'Tenant/Organization'
        required: true
        default: 'luigi'
      app_name:
        description: 'Application name'
        required: true
        default: 'luigi-app'
      app_env:
        description: 'Environment'
        required: true
        type: choice
        options:
          - dev
          - staging
          - qa
          - uat
          - prod
        default: 'dev'
      app_region:
        description: 'App deployment region'
        required: true
        default: 'eu-west-2'

env:
  TENANT_NAME: ${{ github.event.inputs.tenant_name || 'luigi' }}
  APP_NAME: ${{ github.event.inputs.app_name || 'luigi-app' }}
  APP_ENV: ${{ github.event.inputs.app_env || 'dev' }}
  APP_REGION: ${{ github.event.inputs.app_region || 'eu-west-2' }}

jobs:
  # ==========================================
  # Job 1: Infrastructure Discovery
  # ==========================================
  discover:
    name: ðŸ” Infrastructure Discovery
    runs-on: ubuntu-latest
    outputs:
      cluster_env: ${{ steps.discover.outputs.cluster_env }}
      argocd_cluster: ${{ steps.discover.outputs.argocd_cluster }}
      workload_cluster: ${{ steps.discover.outputs.workload_cluster }}
      ecr_repo: ${{ steps.discover.outputs.ecr_repo }}
      namespace: ${{ steps.discover.outputs.namespace }}
      deployment_type: ${{ steps.discover.outputs.deployment_type }}
      ecr_registry: ${{ steps.discover.outputs.ecr_registry }}
      runtime: ${{ steps.discover.outputs.runtime }}
      argocd_exists: ${{ steps.discover.outputs.argocd_cluster_exists }}
      workload_exists: ${{ steps.discover.outputs.workload_exists }}
      ecr_exists: ${{ steps.discover.outputs.ecr_exists }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.APP_REGION }}

      - name: Discover Infrastructure
        id: discover
        run: |
          echo "========================================"
          echo "ðŸ“‹ INFRASTRUCTURE DISCOVERY"
          echo "========================================"
          echo ""
          echo "Input Configuration:"
          echo "  Tenant:      ${{ env.TENANT_NAME }}"
          echo "  App:         ${{ env.APP_NAME }}"
          echo "  Environment: ${{ env.APP_ENV }}"
          echo "  Region:      ${{ env.APP_REGION }}"
          echo ""

          # ========================================
          # DERIVE CLUSTER ENVIRONMENT
          # ========================================
          if [ "${{ env.APP_ENV }}" = "prod" ]; then
            CLUSTER_ENV="prod"
          else
            CLUSTER_ENV="nonprod"
          fi
          echo "cluster_env=$CLUSTER_ENV" >> $GITHUB_OUTPUT
          echo "Derived cluster_env: $CLUSTER_ENV"

          # ========================================
          # BUILD RESOURCE NAMES
          # ========================================
          ARGOCD_CLUSTER="argocd-${{ env.APP_REGION }}"
          WORKLOAD_CLUSTER="${{ env.TENANT_NAME }}-${{ env.APP_REGION }}-${CLUSTER_ENV}"
          ECR_REPO="${{ env.TENANT_NAME }}/${{ env.APP_NAME }}"
          NAMESPACE="${{ env.APP_NAME }}-${{ env.APP_ENV }}"
          
          # Get AWS Account ID for ECR registry
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.APP_REGION }}.amazonaws.com"

          echo "argocd_cluster=$ARGOCD_CLUSTER" >> $GITHUB_OUTPUT
          echo "workload_cluster=$WORKLOAD_CLUSTER" >> $GITHUB_OUTPUT
          echo "ecr_repo=$ECR_REPO" >> $GITHUB_OUTPUT
          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT
          echo "ecr_registry=$ECR_REGISTRY" >> $GITHUB_OUTPUT

          echo ""
          echo "Target Resources:"
          echo "  ArgoCD Cluster:   $ARGOCD_CLUSTER (shared)"
          echo "  Workload Cluster: $WORKLOAD_CLUSTER (tenant)"
          echo "  ECR Repo:         $ECR_REPO"
          echo "  Namespace:        $NAMESPACE"
          echo "  ECR Registry:     $ECR_REGISTRY"
          echo ""

          # ========================================
          # CHECK 1: ArgoCD Cluster
          # ========================================
          echo "Checking ArgoCD Cluster: $ARGOCD_CLUSTER..."
          if aws eks describe-cluster --name "$ARGOCD_CLUSTER" --region ${{ env.APP_REGION }} 2>/dev/null; then
            ARGOCD_CLUSTER_EXISTS="true"
            ARGOCD_STATUS="âœ… EXISTS"
            ARGOCD_ACTION="Using existing ArgoCD cluster"
          else
            ARGOCD_CLUSTER_EXISTS="false"
            ARGOCD_STATUS="âŒ NOT FOUND"
            ARGOCD_ACTION="Will create ArgoCD cluster"
          fi
          echo "argocd_cluster_exists=$ARGOCD_CLUSTER_EXISTS" >> $GITHUB_OUTPUT

          # ========================================
          # CHECK 2: Workload Cluster
          # ========================================
          echo "Checking Workload Cluster: $WORKLOAD_CLUSTER..."
          if aws eks describe-cluster --name "$WORKLOAD_CLUSTER" --region ${{ env.APP_REGION }} 2>/dev/null; then
            WORKLOAD_EXISTS="true"
            WORKLOAD_STATUS="âœ… EXISTS"
            WORKLOAD_ACTION="Using existing workload cluster"
            WORKLOAD_ENDPOINT=$(aws eks describe-cluster --name "$WORKLOAD_CLUSTER" --query 'cluster.endpoint' --output text)
          else
            WORKLOAD_EXISTS="false"
            WORKLOAD_STATUS="âŒ NOT FOUND"
            WORKLOAD_ACTION="Will create workload cluster"
            WORKLOAD_ENDPOINT="N/A"
          fi
          echo "workload_exists=$WORKLOAD_EXISTS" >> $GITHUB_OUTPUT

          # ========================================
          # CHECK 3: ECR Repository
          # ========================================
          echo "Checking ECR Repository: $ECR_REPO..."
          if aws ecr describe-repositories --repository-names "$ECR_REPO" --region ${{ env.APP_REGION }} 2>/dev/null; then
            ECR_EXISTS="true"
            ECR_STATUS="âœ… EXISTS"
            ECR_ACTION="Using existing repository"
          else
            ECR_EXISTS="false"
            ECR_STATUS="âŒ NOT FOUND"
            ECR_ACTION="Will create repository"
          fi
          echo "ecr_exists=$ECR_EXISTS" >> $GITHUB_OUTPUT

          # ========================================
          # DETERMINE DEPLOYMENT TYPE
          # ========================================
          if [ "$ARGOCD_CLUSTER_EXISTS" = "true" ] && [ "$WORKLOAD_EXISTS" = "true" ]; then
            DEPLOY_TYPE="brownfield"
          elif [ "$ARGOCD_CLUSTER_EXISTS" = "true" ] && [ "$WORKLOAD_EXISTS" = "false" ]; then
            DEPLOY_TYPE="partial"
          else
            DEPLOY_TYPE="greenfield"
          fi
          echo "deployment_type=$DEPLOY_TYPE" >> $GITHUB_OUTPUT

          # ========================================
          # AUTO-DETECT RUNTIME
          # ========================================
          if grep -q "FROM python" Dockerfile 2>/dev/null; then
            RUNTIME="python"
          elif grep -q "FROM node" Dockerfile 2>/dev/null; then
            RUNTIME="nodejs"
          elif grep -q "FROM.*gradle\|FROM.*maven" Dockerfile 2>/dev/null; then
            RUNTIME="java"
          elif grep -q "FROM golang" Dockerfile 2>/dev/null; then
            RUNTIME="go"
          else
            RUNTIME="generic"
          fi
          echo "runtime=$RUNTIME" >> $GITHUB_OUTPUT

          # ========================================
          # PRINT STATUS REPORT
          # ========================================
          echo ""
          echo "========================================"
          echo "ðŸ“‹ INFRASTRUCTURE STATUS REPORT"
          echo "========================================"
          echo ""
          echo "ArgoCD Cluster: $ARGOCD_CLUSTER (shared)"
          echo "  â”œâ”€ Status: $ARGOCD_STATUS"
          echo "  â””â”€ Action: $ARGOCD_ACTION"
          echo ""
          echo "Workload Cluster: $WORKLOAD_CLUSTER (tenant)"
          echo "  â”œâ”€ Status: $WORKLOAD_STATUS"
          echo "  â”œâ”€ Action: $WORKLOAD_ACTION"
          echo "  â””â”€ Endpoint: $WORKLOAD_ENDPOINT"
          echo ""
          echo "ECR Repository: $ECR_REPO"
          echo "  â”œâ”€ Status: $ECR_STATUS"
          echo "  â””â”€ Action: $ECR_ACTION"
          echo ""
          echo "========================================"
          echo "ðŸ“¦ DEPLOYMENT TYPE: $DEPLOY_TYPE"
          echo "ðŸ”§ DETECTED RUNTIME: $RUNTIME"
          echo "========================================"

      - name: Job Summary
        run: |
          echo "## ðŸ” Infrastructure Discovery" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Configuration" >> $GITHUB_STEP_SUMMARY
          echo "| Input | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Tenant | \`${{ env.TENANT_NAME }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| App | \`${{ env.APP_NAME }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | \`${{ env.APP_ENV }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Region | \`${{ env.APP_REGION }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Derived Resources" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| ArgoCD Cluster | \`${{ steps.discover.outputs.argocd_cluster }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Workload Cluster | \`${{ steps.discover.outputs.workload_cluster }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| ECR Repo | \`${{ steps.discover.outputs.ecr_repo }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Namespace | \`${{ steps.discover.outputs.namespace }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Type: **${{ steps.discover.outputs.deployment_type }}**" >> $GITHUB_STEP_SUMMARY

  # ==========================================
  # Job 2: Code Quality Scan (SonarQube)
  # ==========================================
  sonarqube:
    name: ðŸ”¬ SonarQube Scan
    runs-on: ubuntu-latest
    needs: discover
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install Dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-cov

      - name: Run Tests with Coverage
        run: |
          pytest --cov=. --cov-report=xml --cov-report=html || true

      - name: SonarQube Scan
        uses: sonarsource/sonarqube-scan-action@master
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
        with:
          args: >
            -Dsonar.projectKey=${{ env.TENANT_NAME }}_${{ env.APP_NAME }}
            -Dsonar.projectName=${{ env.APP_NAME }}
            -Dsonar.sources=.
            -Dsonar.python.coverage.reportPaths=coverage.xml
        continue-on-error: true

      - name: SonarQube Quality Gate
        uses: sonarsource/sonarqube-quality-gate-action@master
        timeout-minutes: 5
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        continue-on-error: true

  # ==========================================
  # Job 3: Create ECR Repository (if needed)
  # ==========================================
  create-ecr:
    name: ðŸ“¦ Create ECR Repository
    runs-on: ubuntu-latest
    needs: discover
    if: needs.discover.outputs.ecr_exists == 'false'
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.APP_REGION }}

      - name: Create ECR Repository
        run: |
          echo "Creating ECR Repository: ${{ needs.discover.outputs.ecr_repo }}"
          
          aws ecr create-repository \
            --repository-name "${{ needs.discover.outputs.ecr_repo }}" \
            --image-scanning-configuration scanOnPush=true \
            --encryption-configuration encryptionType=AES256 \
            --region ${{ env.APP_REGION }}
          
          echo "âœ… ECR Repository created successfully"

  # ==========================================
  # Job 4: Build and Push Docker Image
  # ==========================================
  build:
    name: ðŸ³ Build & Push Image
    runs-on: ubuntu-latest
    needs: [discover, sonarqube, create-ecr]
    if: always() && needs.discover.result == 'success'
    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}
      full_image: ${{ steps.build.outputs.full_image }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.APP_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push Image
        id: build
        run: |
          ECR_REGISTRY="${{ needs.discover.outputs.ecr_registry }}"
          ECR_REPO="${{ needs.discover.outputs.ecr_repo }}"
          IMAGE_TAG="${{ github.sha }}"
          FULL_IMAGE="${ECR_REGISTRY}/${ECR_REPO}:${IMAGE_TAG}"
          
          echo "Building image: $FULL_IMAGE"
          
          docker build \
            --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
            --build-arg VCS_REF=${{ github.sha }} \
            --build-arg VERSION=${{ github.ref_name }} \
            -t $FULL_IMAGE \
            -t ${ECR_REGISTRY}/${ECR_REPO}:latest \
            .
          
          docker push $FULL_IMAGE
          docker push ${ECR_REGISTRY}/${ECR_REPO}:latest
          
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "full_image=$FULL_IMAGE" >> $GITHUB_OUTPUT
          
          echo "âœ… Image pushed successfully: $FULL_IMAGE"

  # ==========================================
  # Job 5: Security Scan (Grype)
  # ==========================================
  security-scan:
    name: ðŸ›¡ï¸ Grype Security Scan
    runs-on: ubuntu-latest
    needs: [discover, build]
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.APP_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Install Grype
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin

      - name: Run Grype Scan
        id: grype
        run: |
          echo "Scanning image: ${{ needs.build.outputs.full_image }}"
          
          grype ${{ needs.build.outputs.full_image }} -o json > grype-report.json
          grype ${{ needs.build.outputs.full_image }} -o table > grype-report.txt
          
          # Count vulnerabilities
          CRITICAL=$(jq '[.matches[] | select(.vulnerability.severity == "Critical")] | length' grype-report.json)
          HIGH=$(jq '[.matches[] | select(.vulnerability.severity == "High")] | length' grype-report.json)
          MEDIUM=$(jq '[.matches[] | select(.vulnerability.severity == "Medium")] | length' grype-report.json)
          LOW=$(jq '[.matches[] | select(.vulnerability.severity == "Low")] | length' grype-report.json)
          
          echo "critical=$CRITICAL" >> $GITHUB_OUTPUT
          echo "high=$HIGH" >> $GITHUB_OUTPUT
          echo "medium=$MEDIUM" >> $GITHUB_OUTPUT
          echo "low=$LOW" >> $GITHUB_OUTPUT
          
          echo "========================================"
          echo "ðŸ›¡ï¸ SECURITY SCAN RESULTS"
          echo "========================================"
          echo "Critical: $CRITICAL"
          echo "High:     $HIGH"
          echo "Medium:   $MEDIUM"
          echo "Low:      $LOW"
          echo "========================================"
          
          # Quality gate: Critical=0, Highâ‰¤10
          if [ "$CRITICAL" -gt 0 ]; then
            echo "âŒ FAILED: $CRITICAL critical vulnerabilities found"
            exit 1
          fi
          
          if [ "$HIGH" -gt 10 ]; then
            echo "âŒ FAILED: $HIGH high vulnerabilities found (threshold: 10)"
            exit 1
          fi
          
          echo "âœ… Security scan PASSED"

      - name: Upload Grype Report
        uses: actions/upload-artifact@v4
        with:
          name: grype-security-report
          path: |
            grype-report.json
            grype-report.txt

      - name: Security Summary
        run: |
          echo "## ðŸ›¡ï¸ Security Scan Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Severity | Count | Threshold | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Critical | ${{ steps.grype.outputs.critical }} | 0 | $([[ ${{ steps.grype.outputs.critical }} -eq 0 ]] && echo 'âœ…' || echo 'âŒ') |" >> $GITHUB_STEP_SUMMARY
          echo "| High | ${{ steps.grype.outputs.high }} | â‰¤10 | $([[ ${{ steps.grype.outputs.high }} -le 10 ]] && echo 'âœ…' || echo 'âŒ') |" >> $GITHUB_STEP_SUMMARY
          echo "| Medium | ${{ steps.grype.outputs.medium }} | - | âš ï¸ |" >> $GITHUB_STEP_SUMMARY
          echo "| Low | ${{ steps.grype.outputs.low }} | - | â„¹ï¸ |" >> $GITHUB_STEP_SUMMARY

  # ==========================================
  # Job 6: Deploy via ArgoCD
  # ==========================================
  deploy:
    name: ðŸš€ Deploy to EKS
    runs-on: ubuntu-latest
    needs: [discover, build, security-scan]
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.APP_REGION }}

      - name: Update Kustomize Image
        run: |
          cd k8s/overlays/${{ env.APP_ENV }}
          
          # Install kustomize
          curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
          sudo mv kustomize /usr/local/bin/
          
          # Update image in kustomization
          kustomize edit set image luigi-app=${{ needs.build.outputs.full_image }}
          
          echo "Updated kustomization.yaml:"
          cat kustomization.yaml

      - name: Commit and Push
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          git add k8s/overlays/${{ env.APP_ENV }}/kustomization.yaml
          git commit -m "ðŸš€ Deploy ${{ env.APP_NAME }} to ${{ env.APP_ENV }} - ${{ github.sha }}" || echo "No changes to commit"
          git push

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --name ${{ needs.discover.outputs.workload_cluster }} \
            --region ${{ env.APP_REGION }}

      - name: Wait for ArgoCD Sync
        run: |
          echo "Waiting for ArgoCD to sync..."
          sleep 30
          
          # Check deployment status
          kubectl rollout status deployment/${{ env.APP_NAME }} \
            -n ${{ needs.discover.outputs.namespace }} \
            --timeout=300s || true

      - name: Verify Deployment
        run: |
          echo "========================================"
          echo "ðŸš€ DEPLOYMENT VERIFICATION"
          echo "========================================"
          
          kubectl get pods -n ${{ needs.discover.outputs.namespace }} -l app=${{ env.APP_NAME }}
          kubectl get svc -n ${{ needs.discover.outputs.namespace }} -l app=${{ env.APP_NAME }}
          
          # Get pod health
          kubectl get pods -n ${{ needs.discover.outputs.namespace }} -l app=${{ env.APP_NAME }} -o jsonpath='{.items[*].status.phase}'

      - name: Deployment Summary
        run: |
          echo "## ðŸš€ Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Tenant | \`${{ env.TENANT_NAME }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| App | \`${{ env.APP_NAME }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | \`${{ env.APP_ENV }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Cluster | \`${{ needs.discover.outputs.workload_cluster }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Namespace | \`${{ needs.discover.outputs.namespace }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Image | \`${{ needs.build.outputs.full_image }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Type | \`${{ needs.discover.outputs.deployment_type }}\` |" >> $GITHUB_STEP_SUMMARY
