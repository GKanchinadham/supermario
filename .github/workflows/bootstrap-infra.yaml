# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Opsera Bootstrap Infrastructure - Creates VPC, EKS, OIDC, ExternalDNS
# Tenant: GKOrg2 | Region: eu-west-2
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: Bootstrap Infrastructure (GKOrg2)

on:
  workflow_dispatch:
    inputs:
      tenant_name:
        description: 'Tenant/Organization'
        required: true
        default: 'gkorg2'
      app_region:
        description: 'AWS Region'
        required: true
        default: 'eu-west-2'
      cluster_env:
        description: 'Cluster Environment'
        required: true
        type: choice
        options:
          - nonprod
          - prod
        default: 'nonprod'
      action:
        description: 'Terraform Action'
        required: true
        type: choice
        options:
          - plan
          - apply
          - destroy
        default: 'plan'

env:
  TENANT_NAME: ${{ github.event.inputs.tenant_name || 'gkorg2' }}
  APP_REGION: ${{ github.event.inputs.app_region || 'eu-west-2' }}
  CLUSTER_ENV: ${{ github.event.inputs.cluster_env || 'nonprod' }}
  TF_ACTION: ${{ github.event.inputs.action || 'plan' }}
  # Short naming convention
  REGION_SHORT: euw2
  VPC_NAME: opsera-vpc
  ARGOCD_CLUSTER: argocd-euw2
  WORKLOAD_CLUSTER: gkorg2-euw2-np

permissions:
  contents: read
  id-token: write

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Terraform Infrastructure Provisioning
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  terraform:
    name: "ðŸ—ï¸ Terraform ${{ github.event.inputs.action }}"
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: terraform

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          ref: gkorgapp2-deploy

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.APP_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"

      - name: Get AWS Account ID
        id: aws
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query 'Account' --output text)
          echo "account_id=$AWS_ACCOUNT_ID" >> $GITHUB_OUTPUT
          echo "AWS Account: $AWS_ACCOUNT_ID"

      - name: Setup Terraform Backend
        run: |
          AWS_ACCOUNT_ID=${{ steps.aws.outputs.account_id }}
          REGION="${{ env.APP_REGION }}"
          BUCKET_NAME="opsera-tf-state-${AWS_ACCOUNT_ID}-${REGION}"
          TABLE_NAME="terraform-state-lock-${REGION}"

          echo "TF_BUCKET=$BUCKET_NAME" >> $GITHUB_ENV
          echo "TF_TABLE=$TABLE_NAME" >> $GITHUB_ENV

          # Create S3 bucket if not exists
          if ! aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
            echo "Creating S3 bucket: $BUCKET_NAME"
            aws s3api create-bucket \
              --bucket "$BUCKET_NAME" \
              --region $REGION \
              --create-bucket-configuration LocationConstraint=$REGION

            aws s3api put-bucket-versioning \
              --bucket "$BUCKET_NAME" \
              --versioning-configuration Status=Enabled

            aws s3api put-bucket-encryption \
              --bucket "$BUCKET_NAME" \
              --server-side-encryption-configuration \
              '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}'
          fi

          # Create DynamoDB table if not exists
          if ! aws dynamodb describe-table --table-name "$TABLE_NAME" --region $REGION 2>/dev/null; then
            echo "Creating DynamoDB table: $TABLE_NAME"
            aws dynamodb create-table \
              --table-name "$TABLE_NAME" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --region $REGION

            aws dynamodb wait table-exists --table-name "$TABLE_NAME" --region $REGION
          fi

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ env.TF_BUCKET }}" \
            -backend-config="key=${{ env.TENANT_NAME }}/infrastructure/terraform.tfstate" \
            -backend-config="region=${{ env.APP_REGION }}" \
            -backend-config="dynamodb_table=${{ env.TF_TABLE }}" \
            -backend-config="encrypt=true"

      - name: Terraform Plan
        if: env.TF_ACTION == 'plan' || env.TF_ACTION == 'apply'
        run: |
          terraform plan \
            -var="tenant_name=${{ env.TENANT_NAME }}" \
            -var="region=${{ env.APP_REGION }}" \
            -var="cluster_env=${{ env.CLUSTER_ENV }}" \
            -var="vpc_name=${{ env.VPC_NAME }}" \
            -var="argocd_cluster_name=${{ env.ARGOCD_CLUSTER }}" \
            -var="workload_cluster_name=${{ env.WORKLOAD_CLUSTER }}" \
            -out=tfplan

      - name: Terraform Apply
        if: env.TF_ACTION == 'apply'
        run: |
          terraform apply -auto-approve tfplan

      - name: Terraform Destroy
        if: env.TF_ACTION == 'destroy'
        run: |
          terraform destroy -auto-approve \
            -var="tenant_name=${{ env.TENANT_NAME }}" \
            -var="region=${{ env.APP_REGION }}" \
            -var="cluster_env=${{ env.CLUSTER_ENV }}" \
            -var="vpc_name=${{ env.VPC_NAME }}" \
            -var="argocd_cluster_name=${{ env.ARGOCD_CLUSTER }}" \
            -var="workload_cluster_name=${{ env.WORKLOAD_CLUSTER }}"

      - name: Get Outputs
        if: env.TF_ACTION == 'apply'
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  TERRAFORM OUTPUTS"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          terraform output -json || true

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Install ArgoCD (after apply)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  install-argocd:
    name: "ðŸ”§ Install ArgoCD"
    runs-on: ubuntu-latest
    needs: terraform
    if: github.event.inputs.action == 'apply'

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.APP_REGION }}

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Configure kubectl for ArgoCD Cluster
        run: |
          aws eks update-kubeconfig \
            --name ${{ env.ARGOCD_CLUSTER }} \
            --region ${{ env.APP_REGION }}

      - name: Install ArgoCD
        run: |
          echo "Installing ArgoCD..."
          
          kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -
          
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          
          echo "Waiting for ArgoCD to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment/argocd-server -n argocd || true
          
          echo "âœ… ArgoCD installed successfully"

      - name: Get ArgoCD Admin Password
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  ARGOCD CREDENTIALS"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "Username: admin"
          echo "Password: (run this command to get it)"
          echo "  kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath='{.data.password}' | base64 -d"
          echo ""
          echo "To access ArgoCD UI:"
          echo "  kubectl port-forward svc/argocd-server -n argocd 8080:443"
          echo "  Then open: https://localhost:8080"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Install ExternalDNS (after ArgoCD)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  install-externaldns:
    name: "ðŸŒ Install ExternalDNS"
    runs-on: ubuntu-latest
    needs: [terraform, install-argocd]
    if: github.event.inputs.action == 'apply'

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.APP_REGION }}

      - name: Install kubectl and Helm
        run: |
          curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

      - name: Configure kubectl for Workload Cluster
        run: |
          aws eks update-kubeconfig \
            --name ${{ env.WORKLOAD_CLUSTER }} \
            --region ${{ env.APP_REGION }}

      - name: Create ExternalDNS IAM Policy
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query 'Account' --output text)
          
          # Create IAM policy for ExternalDNS (Learning #156 - include all zones)
          cat > /tmp/externaldns-policy.json << 'EOF'
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": ["route53:ChangeResourceRecordSets"],
                "Resource": ["arn:aws:route53:::hostedzone/*"]
              },
              {
                "Effect": "Allow",
                "Action": [
                  "route53:ListHostedZones",
                  "route53:ListResourceRecordSets"
                ],
                "Resource": ["*"]
              }
            ]
          }
          EOF

          POLICY_NAME="ExternalDNS-${{ env.WORKLOAD_CLUSTER }}"
          
          # Create or update policy
          if aws iam get-policy --policy-arn "arn:aws:iam::${AWS_ACCOUNT_ID}:policy/${POLICY_NAME}" 2>/dev/null; then
            echo "Policy exists, skipping creation"
          else
            aws iam create-policy \
              --policy-name "$POLICY_NAME" \
              --policy-document file:///tmp/externaldns-policy.json
          fi

      - name: Install ExternalDNS via Helm
        run: |
          helm repo add external-dns https://kubernetes-sigs.github.io/external-dns/
          helm repo update
          
          helm upgrade --install external-dns external-dns/external-dns \
            --namespace kube-system \
            --set provider=aws \
            --set aws.region=${{ env.APP_REGION }} \
            --set txtOwnerId=${{ env.WORKLOAD_CLUSTER }} \
            --set policy=sync \
            --set sources[0]=service \
            --set sources[1]=ingress
          
          echo "âœ… ExternalDNS installed successfully"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Register Workload Cluster with ArgoCD
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  register-cluster:
    name: "ðŸ”— Register Cluster with ArgoCD"
    runs-on: ubuntu-latest
    needs: [terraform, install-argocd, install-externaldns]
    if: github.event.inputs.action == 'apply'

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          ref: gkorgapp2-deploy

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.APP_REGION }}

      - name: Install Tools
        run: |
          curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          
          curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          chmod +x argocd-linux-amd64
          sudo mv argocd-linux-amd64 /usr/local/bin/argocd

      - name: Get Workload Cluster Details
        id: workload
        run: |
          ENDPOINT=$(aws eks describe-cluster --name ${{ env.WORKLOAD_CLUSTER }} --query 'cluster.endpoint' --output text)
          CA_DATA=$(aws eks describe-cluster --name ${{ env.WORKLOAD_CLUSTER }} --query 'cluster.certificateAuthority.data' --output text)
          
          echo "endpoint=$ENDPOINT" >> $GITHUB_OUTPUT
          echo "ca_data=$CA_DATA" >> $GITHUB_OUTPUT

      - name: Configure kubectl for ArgoCD Cluster
        run: |
          aws eks update-kubeconfig \
            --name ${{ env.ARGOCD_CLUSTER }} \
            --region ${{ env.APP_REGION }}

      - name: Create Cluster Secret in ArgoCD
        run: |
          # Create cluster secret for ArgoCD to manage workload cluster
          cat > /tmp/cluster-secret.yaml << EOF
          apiVersion: v1
          kind: Secret
          metadata:
            name: ${{ env.WORKLOAD_CLUSTER }}
            namespace: argocd
            labels:
              argocd.argoproj.io/secret-type: cluster
          type: Opaque
          stringData:
            name: ${{ env.WORKLOAD_CLUSTER }}
            server: ${{ steps.workload.outputs.endpoint }}
            config: |
              {
                "awsAuthConfig": {
                  "clusterName": "${{ env.WORKLOAD_CLUSTER }}",
                  "roleARN": ""
                },
                "tlsClientConfig": {
                  "insecure": false,
                  "caData": "${{ steps.workload.outputs.ca_data }}"
                }
              }
          EOF
          
          kubectl apply -f /tmp/cluster-secret.yaml
          
          echo "âœ… Workload cluster registered with ArgoCD"

      - name: Apply ArgoCD Project and Application
        run: |
          kubectl apply -f argocd/project.yaml
          kubectl apply -f argocd/application.yaml
          
          echo "âœ… ArgoCD Application created"

      - name: Summary
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  INFRASTRUCTURE BOOTSTRAP COMPLETE"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "VPC:              ${{ env.VPC_NAME }}"
          echo "ArgoCD Cluster:   ${{ env.ARGOCD_CLUSTER }}"
          echo "Workload Cluster: ${{ env.WORKLOAD_CLUSTER }}"
          echo ""
          echo "ArgoCD is configured to sync from:"
          echo "  Repo:   https://github.com/GKanchinadham/supermario.git"
          echo "  Branch: gkorgapp2-deploy"
          echo "  Path:   k8s/overlays/dev"
          echo ""
          echo "Next: Run 'Deploy GKOrgApp2 to EKS' workflow to deploy the app"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          echo "## ðŸ—ï¸ Infrastructure Bootstrap Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Name | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| VPC | \`${{ env.VPC_NAME }}\` | âœ… Created |" >> $GITHUB_STEP_SUMMARY
          echo "| ArgoCD Cluster | \`${{ env.ARGOCD_CLUSTER }}\` | âœ… Created |" >> $GITHUB_STEP_SUMMARY
          echo "| Workload Cluster | \`${{ env.WORKLOAD_CLUSTER }}\` | âœ… Created |" >> $GITHUB_STEP_SUMMARY
          echo "| ArgoCD | Installed | âœ… Ready |" >> $GITHUB_STEP_SUMMARY
          echo "| ExternalDNS | Installed | âœ… Ready |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next Step**: Run the 'Deploy GKOrgApp2 to EKS' workflow" >> $GITHUB_STEP_SUMMARY
