name: "Phase 3: Deploy to EKS"

on:
  workflow_dispatch:
    inputs:
      tenant_name:
        description: 'Tenant/Organization'
        required: true
        default: 'luigi'
      app_name:
        description: 'Application name'
        required: true
        default: 'luigi-app'
      app_env:
        description: 'Environment'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
        default: 'dev'
      app_region:
        description: 'AWS Region'
        required: true
        default: 'eu-west-2'
      image_tag:
        description: 'Image tag to deploy (leave empty for latest)'
        required: false
        default: 'latest'

env:
  TENANT_NAME: ${{ github.event.inputs.tenant_name }}
  APP_NAME: ${{ github.event.inputs.app_name }}
  APP_ENV: ${{ github.event.inputs.app_env }}
  APP_REGION: ${{ github.event.inputs.app_region }}
  IMAGE_TAG: ${{ github.event.inputs.image_tag || 'latest' }}

permissions:
  contents: write
  id-token: write

jobs:
  # ==========================================
  # Phase 3A: Verify Prerequisites
  # ==========================================
  verify:
    name: "ðŸ” Verify Prerequisites"
    runs-on: ubuntu-latest
    outputs:
      cluster_name: ${{ steps.setup.outputs.cluster_name }}
      namespace: ${{ steps.setup.outputs.namespace }}
      ecr_uri: ${{ steps.setup.outputs.ecr_uri }}
      full_image: ${{ steps.setup.outputs.full_image }}
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.APP_REGION }}

      - name: Setup and Verify
        id: setup
        run: |
          CLUSTER_NAME="${{ env.TENANT_NAME }}-${{ env.APP_REGION }}-nonprod"
          NAMESPACE="${{ env.APP_NAME }}-${{ env.APP_ENV }}"
          ECR_REPO="${{ env.TENANT_NAME }}/${{ env.APP_NAME }}"
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.APP_REGION }}.amazonaws.com/${ECR_REPO}"
          FULL_IMAGE="${ECR_URI}:${{ env.IMAGE_TAG }}"
          
          echo "========================================"
          echo "ðŸ” DEPLOYMENT CONFIGURATION"
          echo "========================================"
          echo "Cluster: $CLUSTER_NAME"
          echo "Namespace: $NAMESPACE"
          echo "Image: $FULL_IMAGE"
          
          # Verify cluster exists
          if ! aws eks describe-cluster --name "$CLUSTER_NAME" 2>/dev/null; then
            echo "âŒ Cluster not found! Run Phase 1 first."
            exit 1
          fi
          
          # Verify image exists
          if ! aws ecr describe-images --repository-name "$ECR_REPO" --image-ids imageTag=${{ env.IMAGE_TAG }} 2>/dev/null; then
            echo "âŒ Image not found! Run Phase 2 first."
            exit 1
          fi
          
          echo "âœ… All prerequisites verified"
          
          echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT
          echo "ecr_uri=$ECR_URI" >> $GITHUB_OUTPUT
          echo "full_image=$FULL_IMAGE" >> $GITHUB_OUTPUT

  # ==========================================
  # Phase 3B: Deploy Application
  # ==========================================
  deploy:
    name: "ðŸš€ Deploy Application"
    runs-on: ubuntu-latest
    needs: verify
    outputs:
      service_url: ${{ steps.deploy.outputs.service_url }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.APP_REGION }}

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --name "${{ needs.verify.outputs.cluster_name }}" --region ${{ env.APP_REGION }}

      - name: Create Namespace
        run: |
          kubectl create namespace ${{ needs.verify.outputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Ensure SSL Certificate
        id: ssl
        run: |
          DOMAIN="*.agents.opsera-labs.com"
          
          echo "========================================"
          echo "ðŸ” CHECKING SSL CERTIFICATE"
          echo "========================================"
          
          # Check if certificate exists in this region
          CERT_ARN=$(aws acm list-certificates --query "CertificateSummaryList[?DomainName=='$DOMAIN'].CertificateArn" --output text)
          
          if [ -n "$CERT_ARN" ] && [ "$CERT_ARN" != "None" ]; then
            echo "âœ… SSL Certificate found: $CERT_ARN"
            echo "cert_arn=$CERT_ARN" >> $GITHUB_OUTPUT
            echo "https_enabled=true" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ No SSL certificate found for $DOMAIN in ${{ env.APP_REGION }}"
            echo "Requesting new certificate..."
            
            NEW_CERT_ARN=$(aws acm request-certificate \
              --domain-name "$DOMAIN" \
              --validation-method DNS \
              --query 'CertificateArn' --output text 2>/dev/null || echo "")
            
            if [ -n "$NEW_CERT_ARN" ]; then
              echo "ðŸ“ Certificate requested: $NEW_CERT_ARN"
              echo "â³ Certificate needs DNS validation (may take a few minutes)"
              echo "cert_arn=$NEW_CERT_ARN" >> $GITHUB_OUTPUT
              echo "https_enabled=pending" >> $GITHUB_OUTPUT
            else
              echo "âš ï¸ Could not request certificate, proceeding with HTTP only"
              echo "https_enabled=false" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Deploy Application
        id: deploy
        run: |
          NAMESPACE="${{ needs.verify.outputs.namespace }}"
          FULL_IMAGE="${{ needs.verify.outputs.full_image }}"
          
          echo "========================================"
          echo "ðŸš€ DEPLOYING APPLICATION"
          echo "========================================"
          echo "Namespace: $NAMESPACE"
          echo "Image: $FULL_IMAGE"
          
          # Apply Kubernetes manifests directly
          cat << EOF | kubectl apply -f -
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${{ env.APP_NAME }}
            namespace: $NAMESPACE
            labels:
              app: ${{ env.APP_NAME }}
              tenant: ${{ env.TENANT_NAME }}
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: ${{ env.APP_NAME }}
            template:
              metadata:
                labels:
                  app: ${{ env.APP_NAME }}
                  tenant: ${{ env.TENANT_NAME }}
              spec:
                containers:
                  - name: ${{ env.APP_NAME }}
                    image: $FULL_IMAGE
                    ports:
                      - containerPort: 5000
                    env:
                      - name: PORT
                        value: "5000"
                      - name: FLASK_ENV
                        value: "production"
                    resources:
                      requests:
                        memory: "128Mi"
                        cpu: "100m"
                      limits:
                        memory: "256Mi"
                        cpu: "500m"
                    livenessProbe:
                      httpGet:
                        path: /health
                        port: 5000
                      initialDelaySeconds: 10
                      periodSeconds: 30
                    readinessProbe:
                      httpGet:
                        path: /health
                        port: 5000
                      initialDelaySeconds: 5
                      periodSeconds: 10
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ env.APP_NAME }}
            namespace: $NAMESPACE
            labels:
              app: ${{ env.APP_NAME }}
            annotations:
              # Custom DNS hostname
              external-dns.alpha.kubernetes.io/hostname: ${{ env.APP_NAME }}.agents.opsera-labs.com
              # AWS NLB with HTTPS (if certificate available)
              service.beta.kubernetes.io/aws-load-balancer-type: nlb
              service.beta.kubernetes.io/aws-load-balancer-ssl-cert: ${{ steps.ssl.outputs.cert_arn }}
              service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "443"
              service.beta.kubernetes.io/aws-load-balancer-backend-protocol: http
          spec:
            type: LoadBalancer
            ports:
              - name: https
                port: 443
                targetPort: 5000
                protocol: TCP
              - name: http
                port: 80
                targetPort: 5000
                protocol: TCP
            selector:
              app: ${{ env.APP_NAME }}
          EOF
          
          echo "Waiting for deployment to be ready..."
          kubectl rollout status deployment/${{ env.APP_NAME }} -n $NAMESPACE --timeout=300s
          
          echo "Waiting for LoadBalancer..."
          CUSTOM_DOMAIN="${{ env.APP_NAME }}.agents.opsera-labs.com"
          for i in {1..30}; do
            URL=$(kubectl get svc ${{ env.APP_NAME }} -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null)
            if [ -n "$URL" ] && [ "$URL" != "null" ]; then
              echo "service_url=https://$CUSTOM_DOMAIN" >> $GITHUB_OUTPUT
              echo "lb_url=$URL" >> $GITHUB_OUTPUT
              break
            fi
            echo "Waiting for LoadBalancer... ($i/30)"
            sleep 10
          done
          
          echo ""
          echo "========================================"
          echo "âœ… DEPLOYMENT COMPLETE"
          echo "========================================"
          kubectl get pods -n $NAMESPACE
          kubectl get svc -n $NAMESPACE

      - name: Create Route53 DNS Record
        run: |
          NAMESPACE="${{ needs.verify.outputs.namespace }}"
          CUSTOM_DOMAIN="${{ env.APP_NAME }}.agents.opsera-labs.com"
          HOSTED_ZONE_ID="Z00814191D1XSXELJVTKT"
          
          # Get LoadBalancer hostname
          LB_HOSTNAME=$(kubectl get svc ${{ env.APP_NAME }} -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          
          if [ -z "$LB_HOSTNAME" ] || [ "$LB_HOSTNAME" = "null" ]; then
            echo "âš ï¸ LoadBalancer not ready, skipping DNS setup"
            exit 0
          fi
          
          # Get the LoadBalancer's hosted zone ID (for eu-west-2 ELB)
          # eu-west-2 ELB hosted zone: Z28GJK7Z4W9IOJ
          LB_ZONE_ID="ZHURV8PSTC4K8"
          
          echo "========================================"
          echo "ðŸŒ CREATING DNS RECORD"
          echo "========================================"
          echo "Domain: $CUSTOM_DOMAIN"
          echo "Target: $LB_HOSTNAME"
          
          # Create Route53 CNAME record
          aws route53 change-resource-record-sets \
            --hosted-zone-id "$HOSTED_ZONE_ID" \
            --change-batch '{
              "Changes": [{
                "Action": "UPSERT",
                "ResourceRecordSet": {
                  "Name": "'"$CUSTOM_DOMAIN"'",
                  "Type": "CNAME",
                  "TTL": 300,
                  "ResourceRecords": [{"Value": "'"$LB_HOSTNAME"'"}]
                }
              }]
            }'
          
          echo ""
          echo "âœ… DNS Record created: $CUSTOM_DOMAIN -> $LB_HOSTNAME"
          echo "Note: DNS propagation may take 2-5 minutes"

      - name: Phase 3 Summary
        run: |
          CUSTOM_DOMAIN="${{ env.APP_NAME }}.agents.opsera-labs.com"
          echo "## ðŸš€ Phase 3: Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Cluster | \`${{ needs.verify.outputs.cluster_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Namespace | \`${{ needs.verify.outputs.namespace }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Image | \`${{ needs.verify.outputs.full_image }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Custom URL** | \`http://$CUSTOM_DOMAIN\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next:** Verify endpoint health" >> $GITHUB_STEP_SUMMARY

  # ==========================================
  # Phase 3C: Verify Endpoint
  # ==========================================
  verify-endpoint:
    name: "âœ… Verify Endpoint"
    runs-on: ubuntu-latest
    needs: [verify, deploy]
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.APP_REGION }}

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --name "${{ needs.verify.outputs.cluster_name }}" --region ${{ env.APP_REGION }}

      - name: Wait for Pods Ready
        run: |
          NAMESPACE="${{ needs.verify.outputs.namespace }}"
          
          echo "========================================"
          echo "â³ WAITING FOR PODS TO BE READY"
          echo "========================================"
          
          for i in {1..30}; do
            READY=$(kubectl get pods -n $NAMESPACE -l app=${{ env.APP_NAME }} \
              -o jsonpath='{.items[*].status.conditions[?(@.type=="Ready")].status}' | \
              tr ' ' '\n' | grep -c True || echo 0)
            
            echo "Attempt $i/30: $READY pods ready"
            
            # Check for errors
            if kubectl get pods -n $NAMESPACE | grep -q "ImagePullBackOff\|ErrImagePull\|CrashLoopBackOff"; then
              echo "âŒ ERROR: Pod issues detected!"
              kubectl describe pods -n $NAMESPACE -l app=${{ env.APP_NAME }}
              exit 1
            fi
            
            [ "$READY" -ge 2 ] && echo "âœ… All pods ready!" && break
            sleep 10
          done

      - name: Verify Endpoint Health
        run: |
          NAMESPACE="${{ needs.verify.outputs.namespace }}"
          CUSTOM_DOMAIN="${{ env.APP_NAME }}.agents.opsera-labs.com"
          
          # Get LoadBalancer URL
          LB_URL=$(kubectl get svc ${{ env.APP_NAME }} -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          
          if [ -z "$LB_URL" ] || [ "$LB_URL" = "null" ]; then
            echo "âš ï¸ LoadBalancer URL not ready yet"
            exit 0
          fi
          
          echo "========================================"
          echo "ðŸ” VERIFYING ENDPOINT HEALTH"
          echo "========================================"
          echo "Custom Domain: https://$CUSTOM_DOMAIN"
          echo "LoadBalancer: $LB_URL"
          
          # First verify via LoadBalancer directly (HTTP on port 80)
          echo ""
          echo "Step 1: Verifying LoadBalancer (HTTP)..."
          for i in {1..30}; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 10 "http://$LB_URL/health" || echo "000")
            echo "Attempt $i/30: HTTP $STATUS"
            
            if [ "$STATUS" = "200" ]; then
              echo "âœ… LoadBalancer responding!"
              break
            fi
            sleep 10
          done
          
          # Try HTTPS on custom domain
          echo ""
          echo "Step 2: Verifying HTTPS Custom Domain..."
          for i in {1..15}; do
            STATUS=$(curl -sk -o /dev/null -w "%{http_code}" --connect-timeout 10 "https://$CUSTOM_DOMAIN/health" 2>/dev/null || echo "000")
            echo "Attempt $i/15: HTTPS $STATUS"
            
            if [ "$STATUS" = "200" ]; then
              echo ""
              echo "========================================"
              echo "âœ… HTTPS ENDPOINT VERIFIED"
              echo "========================================"
              echo ""
              echo "ðŸŽ‰ APPLICATION IS LIVE!"
              echo "ðŸ” URL: https://$CUSTOM_DOMAIN"
              exit 0
            fi
            sleep 10
          done
          
          # Fallback: Try HTTP on custom domain
          echo ""
          echo "Step 3: Trying HTTP fallback..."
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 10 "http://$CUSTOM_DOMAIN/health" 2>/dev/null || echo "000")
          if [ "$STATUS" = "200" ]; then
            echo "âœ… HTTP endpoint working (HTTPS certificate may be pending)"
            echo "URL: http://$CUSTOM_DOMAIN"
            exit 0
          fi
          
          echo ""
          echo "========================================"
          echo "âš ï¸ Custom domain may need more time for DNS/SSL"
          echo "========================================"
          echo "LoadBalancer URL: http://$LB_URL"
          echo "Custom domain (pending): https://$CUSTOM_DOMAIN"

      - name: Final Summary
        run: |
          NAMESPACE="${{ needs.verify.outputs.namespace }}"
          CUSTOM_DOMAIN="${{ env.APP_NAME }}.agents.opsera-labs.com"
          LB_URL=$(kubectl get svc ${{ env.APP_NAME }} -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "pending")
          
          echo "## âœ… Deployment Verification Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŽ‰ Application Endpoints" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **ðŸ” HTTPS URL** | \`https://$CUSTOM_DOMAIN\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Health Check | \`https://$CUSTOM_DOMAIN/health\` |" >> $GITHUB_STEP_SUMMARY
          echo "| LoadBalancer | \`$LB_URL\` |" >> $GITHUB_STEP_SUMMARY
          echo "| SSL Certificate | \`${{ needs.deploy.outputs.cert_arn || 'pending' }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Status | âœ… LIVE |" >> $GITHUB_STEP_SUMMARY
